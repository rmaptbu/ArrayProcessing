<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Homogeneous Propagation Medium Example (k-Wave)</title>
	<link rel="stylesheet" href="docstyle.css" type="text/css">
	<meta name="description" content="Homogeneous Propagation Medium Example.">
</head>

<body>

<table width="100%" border="0" cellpadding="0" cellspacing="0" bgcolor="#e7ebf7">
    <tr>
        <td valign="baseline">
            <b>k-Wave Toolbox</b>
        </td>
        <td valign="baseline" align="right">
            <a href="k-wave_initial_value_problems.html"><img src="images/b_prev.gif" border="0" align="bottom" alt="Previous"></a>&nbsp;&nbsp;&nbsp;<a href="example_ivp_binary_sensor_mask.html"><img src="images/b_next.gif" border="0" align="bottom" alt="Next"></a>
        </td>
    </tr>
</table>

<a name="top_of_page"></a>
<h2 class="title">Homogeneous Propagation Medium Example</h2>

<table border="0" cellpadding="4" cellspacing="0" class="pagenavtable">
    <tr>
        <th>On this page&#8230;</th>
    </tr>
    <tr>
        <td>
            <p><a href="#heading1">Overview</a></p>
            <p><a href="#heading2">Creating the k-space grid</a></p>
            <p><a href="#heading3">Avoiding the perfectly matched layer</a></p>
            <p><a href="#heading4">Defining the medium properties</a></p>
            <p><a href="#heading5">Defining the initial pressure distribution</a></p>
            <p><a href="#heading6">Defining the sensor mask</a></p>
            <p><a href="#heading7">Running the simulation</a></p>
        </td>
    </tr>
</table>

<a name="heading1"></a>
<h3 class="title">Overview</h3>

<p>This example provides a simple demonstration of using k-Wave for the simulation and detection of the pressure field generated by an  initial pressure distribution within a two-dimensional homogeneous propagation medium.</p>

<p>
    <ul>
        <li><a href="matlab:edit([getkWavePath('examples') 'example_ivp_homogeneous_medium.m']);" target="_top">open the file</a> in the MATLAB Editor</li>
        <li><a href="matlab:run([getkWavePath('examples') 'example_ivp_homogeneous_medium']);" target="_top">run the file</a> in MATLAB</li>
    </ul>
</p>

<p></p>
<p><img src="images/doc_to_top_up.gif">&nbsp;<a href="#top_of_page">Back to Top</a></p>

<a name="heading2"></a>
<h3 class="title">Creating the k-space grid</h3>

<p>The simulation functions used in k-Wave require four input structures. These define the properties of the computational grid, the material properties of the medium, the properties and locations of any acoustic sources, and the properties and locations of the sensor points used to record the evolution of the pressure and velocity fields over time. Starting with the computational grid, the medium discretisation is performed by <code><a href="makeGrid.html">makeGrid</a></code>. Both the total number of grid points (Nx, Ny) as well as the spacing between the grid points (dx, dy) in each Cartesian direction are used to compute the discretisation, and an object of the <code>kWaveGrid</code> class is returned. As the numerical techniques used in k-Wave are based heavily on the fast Fourier transform (FFT), the simulations will be fastest when the number of grid points in each direction is given by a power of two or has small prime factors (see <code><a href="matlab: doc fft2">fft2</a></code> and <code><a href="checkFactors.html">checkFactors</a></code>).</p>

<pre class="programlisting">
% create the computational grid
Nx = 128;           % number of grid points in the x (row) direction
Ny = 128;           % number of grid points in the y (column) direction
dx = 0.1e-3;        % grid point spacing in the x direction  [m]
dy = 0.1e-3;        % grid point spacing in the y direction  [m]
kgrid = makeGrid(Nx, dx, Ny, dy);
</pre>

<p>The object <code>kgrid</code> contains numerous properties, including matrices of the computational wavenumbers (<code>kgrid.kx</code>, <code>kgrid.ky</code>, and <code>kgrid.k</code>) and Cartesian coordinates of the grid points (<code>kgrid.x</code>, <code>kgrid.y</code>). These properties are used by many k-Wave functions (for a full list, see the help file for <code><a href="makeGrid.html">makeGrid</a></code>).</p>

<p></p>
<p><img src="images/doc_to_top_up.gif">&nbsp;<a href="#top_of_page">Back to Top</a></p>

<a name="heading3"></a>
<h3 class="title">Avoiding the perfectly matched layer</h3>

<p>When the acoustic waves reach the edge of the computational domain, they are absorbed by a special type of anisotropic absorbing boundary layer known as a perfectly matched layer (PML). The effects of the layer can be seen by watching what happens to the propagating waves as they get close to the edge of the computational domain. By default, this layer occupies a strip of 20 grid points (10 grid points in 3D) around the edge of the domain <em>inside</em> the computational domain specified using <code>makeGrid</code>. To avoid strange effects, care must be taken not to place the source or sensor points inside this layer. Alternatively, the perfectly matched layer can be set to be <em>outside</em> the computational domain set by the user. See <a href="example_na_controlling_the_pml.html">Controlling The Absorbing Boundary Layer Example</a> for more detailed instructions on how to modify the properties and position of the perfectly matched layer.</p>

<p></p>
<p><img src="images/doc_to_top_up.gif">&nbsp;<a href="#top_of_page">Back to Top</a></p>

<a name="heading4"></a>
<h3 class="title">Defining the medium properties</h3>

<p>For a homogeneous medium, the sound speed is set as a scalar value in SI units (i.e., metres per second). Power law acoustic absorption can also be optionally set by assigning values to <code>medium.alpha_coeff</code> and <code>medium.alpha_power</code>. These respectively correspond to the power law coefficient or prefactor in units of dB/(MHz^y cm) and the power law exponent or power y. It is useful to note that for a homogeneous medium, the computation of the acoustic pressure is not dependent on the ambient density. Consequently, if no velocity inputs or outputs are required, <code>medium.density</code> does not need to be specified.</p>

<pre class="programlisting">
% define the properties of the propagation medium
medium.sound_speed = 1500;  % [m/s]
medium.alpha_coeff = 0.75;  % [dB/(MHz^y cm)]
medium.alpha_power = 1.5;
</pre>

<p>The grid spacing (<code>dx</code> and <code>dy</code>) and the sound speed govern the maximum frequency that the simulation grid is able to propagate. This frequency (for each Cartesian direction) can be calculated by <code>f_max_x = medium.sound_speed/(2*dx)</code>. For modelling nonlinear effects, <code>medium.BonA</code> should also be specified. In this case, k-Wave includes a number of additional nonlinear terms in the discrete governing equations.</p>

<p></p>
<p><img src="images/doc_to_top_up.gif">&nbsp;<a href="#top_of_page">Back to Top</a></p>

<a name="heading5"></a>
<h3 class="title">Defining the initial pressure distribution</h3>

<p>The initial pressure distribution is set as a matrix which contains the initial pressure values for each grid point. This matrix must be the same size as the medium discretisation defined by the computational grid (i.e., it must have <code>Nx</code> rows and <code>Ny</code> columns). Several functions are included in the toolbox for the creation of simple geometric shapes. In this example, the function <code><a href="makeDisc.html">makeDisc</a></code> is used to create an initial pressure distribution in the shape of two small discs with different diameters. This distribution is assigned to the <code>p0</code> field of the <code>source</code> structure. There are no restrictions on <code>source.p0</code> except that it must be the same size as the computational grid.</p>

<pre class="programlisting">
% create initial pressure distribution using makeDisc
disc_magnitude = 5; % [Pa]
disc_x_pos = 50;    % [grid points]
disc_y_pos = 50;    % [grid points]
disc_radius = 8;    % [grid points]
disc_1 = disc_magnitude*makeDisc(Nx, Ny, disc_x_pos, disc_y_pos, disc_radius);

disc_magnitude = 3; % [Pa]
disc_x_pos = 80;    % [grid points]
disc_y_pos = 60;    % [grid points]
disc_radius = 5;    % [grid points]
disc_2 = disc_magnitude*makeDisc(Nx, Ny, disc_x_pos, disc_y_pos, disc_radius);

source.p0 = disc_1 + disc_2;
</pre>

<p></p>
<p><img src="images/doc_to_top_up.gif">&nbsp;<a href="#top_of_page">Back to Top</a></p>

<a name="heading6"></a>
<h3 class="title">Defining the sensor mask</h3>

<p>The sensor mask defines the positions within the computational domain where the pressure field is recorded at each time-step. The sensor mask can be given in one of three ways:</p>
<ol>
<li>A binary matrix which specifies the grid points that record the data (see the <a href="example_ivp_binary_sensor_mask.html">Using A Binary Sensor Mask Example</a>)</li>
<li>The grid coordinates of two opposing corners of a line (1D), rectangle (2D) or cuboid (3D) (see the <a href="example_ivp_opposing_corners_sensor_mask.html">Defining A Sensor Mask By Opposing Corners Example</a>)</li>
<li>A set of Cartesian coordinates lying within the dimensions of the computational domain.</li>
</ol>
<p>In 2D, Cartesian coordinates must be specified as a 2 x N matrix, where the Cartesian origin is assumed to be in the center of the grid. Here the function <code><a href="makeCartCircle.html">makeCartCircle</a></code> is used to set the sensor mask to the Cartesian coordinates of a set of evenly spaced points on a circle.</p>

<pre class="programlisting">
% define a centered circular sensor
sensor_radius = 4e-3;   % [m]
num_sensor_points = 50;
sensor.mask = makeCartCircle(sensor_radius, num_sensor_points);
</pre>

<p>A plot of the initial pressure distribution and the sensor mask is given below. By default, the pressure at the Cartesian points in 2D is computed at each time step using linear interpolation.</p>

<img src="images/example_ivp_homogeneous_medium_01.png" height="420" width="561">

<p></p>
<p><img src="images/doc_to_top_up.gif">&nbsp;<a href="#top_of_page">Back to Top</a></p>

<a name="heading7"></a>
<h3 class="title">Running the simulation</h3>

<p>The computation is started by calling the function <code><a href="kspaceFirstOrder2D.html">kspaceFirstOrder2D</a></code> with the four input structures defined above. By default, a visualisation of the propagating wave-field and a status bar are displayed, with frame updates every ten time-steps. The default k-Wave color map displays positive pressures as yellows to reds to black, and negative pressures as light to dark blue-greys (see <code><a href="getColorMap.html">getColorMap</a></code>). 

<pre class="programlisting">
% run the simulation
sensor_data = kspaceFirstOrder2D(kgrid, medium, source, sensor);
</pre>

<p>As the function runs, status updates and computational parameters are printed to the command line.</p>

<pre class="programlisting">
Running k-Wave simulation...
  start time: 14-Oct-2011 17:31:24
  reference sound speed: 1500m/s
  dt: 20ns, t_end: 12.06us, time steps: 604
  input grid size: 128 by 128 grid points (12.8 by 12.8mm)
  maximum supported frequency: 7.5MHz
  smoothing p0 distribution...
  calculating Delaunay triangulation...
  precomputation completed in 0.46863s
  starting time loop...
  estimated simulation time 2.8516s...
  simulation completed in 3.8546s
  total computation time 4.349s
</pre>

<p>When the time loop has completed, the function returns the recorded time series at each of sensor points defined by <code>sensor.mask</code>. This is indexed as <code>sensor_data(sensor_point_index, time_index)</code>. For a Cartesian sensor mask, the time series are returned in the same order as the Cartesian coordinates specified in <code>sensor.mask</code>. A visualisation of the sensor data recorded in this example is given below.</p>

<pre class="programlisting">
% plot the simulated sensor data
figure;
imagesc(sensor_data, [-1, 1]);
colormap(getColorMap);
ylabel('Sensor Position');
xlabel('Time Step');
colorbar;
</pre>

<img src="images/example_ivp_homogeneous_medium_02.png" height="420" width="561">

<p></p>
<p><img src="images/doc_to_top_up.gif">&nbsp;<a href="#top_of_page">Back to Top</a></p>

<p></p>
<table class="nav" summary="Navigation aid" border="0" width="100%" cellpadding="0" cellspacing="0" bgcolor="#e7ebf7">
    <tr valign="top">
        <td align="left" width="20"><a href="k-wave_initial_value_problems.html"><img src="images/b_prev.gif" border="0" align="bottom" alt="Previous"></a>&nbsp;</td>
        <td align="left">Initial Value Problems</td>
        <td>&nbsp;</td>
        <td align="right">Using A Binary Sensor Mask</td>
        <td align="right" width="20"><a href="example_ivp_binary_sensor_mask.html"><img src="images/b_next.gif" border="0" align="bottom" alt="Next"></a></td>
    </tr>
</table>

<br>
<p class="copy">&copy; 2009-2014 Bradley Treeby and Ben Cox.</p>
</body></html>
